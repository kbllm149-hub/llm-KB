好的，我將您提供的 **`qa_only`** 和 **`qa_graph`** 兩個函式的核心流程，以條列式和圖示化的方式呈現，幫助您清晰地理解這兩種 RAG 模式在檢索階段的差異。

---

## 1. 🔍 純向量檢索 RAG 流程 (`qa_only`)

這代表傳統的 RAG 模式，僅依賴文本塊的語義相似度進行檢索。

| 步驟編號 | 流程名稱 | 核心動作 | 知識來源 |
| :---: | :--- | :--- | :--- |
| **1** | **問題嵌入** | 將用戶問題 (Query) 轉換為向量（Embedding）。 | Query |
| **2** | **向量相似性檢索** | 在 Neo4j 的向量索引中，查找與問題向量最相似的 **Top K** 個 `(:Chunk)` 節點。 | `(:Chunk)` 節點的 `embedding` 屬性 |
| **3** | **上下文準備** | 提取這 Top K 個 Chunk 的原始文本內容。 | `(:Chunk)` 節點的 `text` 屬性 |
| **4** | **答案生成** | 將原始問題與提取的上下文一起送入 **LLM**，生成最終答案。 | LLM |

### 流程圖示 (條列式)

1.  **用戶問題**
2.  $\rightarrow$ **問題向量化**
3.  $\rightarrow$ **[Neo4j 向量索引]** 查詢 $\rightarrow$ 獲取 **Top K 相似 Chunk**
4.  $\rightarrow$ **LLM 生成** (Query + Chunk 文本)
5.  $\rightarrow$ **最終答案**

---

## 2. 🧠 圖形擴展 RAG 流程 (`qa_graph`)

這代表 GraphRAG 的核心優勢，利用知識圖譜的**結構關係**來豐富檢索結果，特別適用於複雜推理問題。

| 步驟編號 | 流程名稱 | 核心動作 | 知識來源 |
| :---: | :--- | :--- | :--- |
| **1** | **初始向量檢索** | (同 `qa_only` 步驟 1-2) 查找 **Top K** 相似的 **初始 Chunk**。 | `(:Chunk)` 節點 |
| **2** | **實體識別** | 透過 **`[:MENTIONS]`** 關係，從這些初始 Chunk 連接到它們所提及的 **實體** 節點。 | `(:Chunk)-[:MENTIONS]->(:Entity)` |
| **3** | **圖形擴展** | 從步驟 2 識別出的實體出發，沿著 **`[:RELATION]`** 關係擴展到其**鄰近實體**，形成一個相關的**知識子圖**（深度由 `max_depth` 參數控制）。 | `(:Entity)-[:RELATION]->(:Entity)` |
| **4** | **增強上下文** | 收集：1. 初始 Chunk 文本；2. 擴展出的所有**結構化圖譜資訊**（實體和關係），將這些圖譜資訊**轉換為文本**。 | 初始 Chunk 文本 + 知識子圖 |
| **5** | **答案生成** | 將原始問題與增強後的上下文（Chunk 文本 + 圖譜文本）一起送入 **LLM**，生成最終答案。 | LLM |

### 流程圖示 (條列式)

1.  **用戶問題**
2.  $\rightarrow$ **問題向量化**
3.  $\rightarrow$ **[Neo4j 向量索引]** 查詢 $\rightarrow$ 獲取 **初始 Chunk**
4.  $\rightarrow$ **[Graph 擴展]** 依 `[:MENTIONS]` 找**實體**
5.  $\rightarrow$ 依 `[:RELATION]` 向外擴展 **知識子圖** (例如 1 跳)
6.  $\rightarrow$ **LLM 生成** (Query + 初始 Chunk 文本 + **圖譜結構化文本**)
7.  $\rightarrow$ **最終答案**